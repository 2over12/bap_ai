open Core_kernel

module type CPO = sig 
  include AbstractDomain.CPO
end



(* TODO so if we want like a reduced product domain then should ensure that whenever bottom 
  is generated by this module then bottom is removed from the map

additionally dont need to run join if x <= y || y <= x for instance*)
module MakeMap(X: AbstractDomain.SET)(Y: AbstractDomain.CPO) = struct 
  module T = struct 
    type t = Y.t X.Map.t [@@deriving compare, sexp]
  end
  type t = T.t [@@deriving sexp]

  include Comparable.Make(T)



  let pairwise_function f x y = let mlist =  List.map ~f:(fun k -> 
    let maybe_nval = f (X.Map.find x k) (X.Map.find y k) in 
    Option.map ~f:(fun v -> (k, v)) maybe_nval ) (Base.Set.to_list (Base.Set.union (X.Map.key_set x) (X.Map.key_set y)))
  in List.filter_map ~f:(ident) mlist |> X.Map.of_alist_exn

  let checked_op (f: Y.t -> Y.t -> Y.t) x y = let res = f x y in if (Poly.(=) res Y.bot) then None else Some res

  let pairwise_function_inclusive ~f:(f: Y.t -> Y.t -> Y.t) x y = pairwise_function (fun x' y' -> match(x',y') with 
  | (None, None) -> None
  | (Some x', None) -> Some x'
  | (None, Some y') -> Some y'
  | (Some x',Some y') ->  checked_op f x' y') x y


  let pairwise_function_exclusive ~f:(f: Y.t -> Y.t -> Y.t) x y = pairwise_function (fun x' y' -> match(x',y') with 
  | (_, None) -> None
  | (None, _) -> None
  | (Some x',Some y') -> checked_op f x' y') x y

  let bot = X.Map.empty

  let narrow x y = 
    pairwise_function_inclusive ~f:Y.narrow x y 

  let widen x y = pairwise_function_inclusive ~f:Y.widen x y

  let join x y = pairwise_function_inclusive ~f:Y.join x y 

  let meet x y = pairwise_function_exclusive ~f:Y.meet x y 

  let le x y = x<= y

  let eq = X.Map.equal Y.eq
  

  let get m x = X.Map.find m x |> Option.value ~default:Y.bot
end

